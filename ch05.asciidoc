[[I_chapter5_d1e1987]]

== Widgets

One of the challenges in web development is that we have to coordinate three different client-side technologies: HTML, CSS, and JavaScript. Worse still, we have to place these components in different locations on the page: CSS in a style tag in the head, JavaScript in a script tag in the head, and HTML in the body. And never mind if you want to put your CSS and JavaScript in separate files!

In practice, this works out fairly nicely when building a single page, because we can separate our structure (HTML), style (CSS), and logic (JavaScript). But when we want to build modular pieces of code that can be easily composed, it can be a headache to coordinate all three pieces separately. Widgets are Yesod&rsquo;s solution to the problem. They also help with the issue of including libraries, such as jQuery, one time only.

Our four template languages—Hamlet, Cassius, Lucius and Julius—provide the raw tools for constructing your output. Widgets provide the glue that allows them to work together seamlessly.

[[I_sect15_d1e1996]]

=== Synopsis


[source, haskell]
----
getRootR = defaultLayout $ do
    setTitle "My Page Title"
    toWidget [lucius| h1 { color: green; } |]
    addScriptRemote "https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"
    toWidget [julius|
$(function() {
    $("h1").click(function(){ alert("You clicked on the heading!"); });
});
|]
    toWidgetHead [hamlet| <meta name=keywords content="some sample keywords">|]
    toWidget [hamlet| <h1>Here's one way of including content |]
    [whamlet| <h2>Here's another |]
    toWidgetBody [julius| alert("This is included in the body itself"); |]
----

This produces the following HTML (indentation added):


----
<!DOCTYPE html> 
<html>
    <head>
        <title>My Page Title</title>
        <style>h1 { color : green }</style>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
        <script>
$(function() {
    $("h1").click(function(){ alert("You clicked on the heading!"); });
});
</script>
        <meta name="keywords" content="some sample keywords">
    </head>
    <body>
        <h1>Here's one way of including content </h1>
        <h2>Here's another </h2>
        <script> alert("This is included in the body itself"); </script>
    </body>
</html>
----

[[I_sect15_d1e2005]]

=== What&rsquo;s in a Widget?

At a very superficial level, an HTML document is just a bunch of nested tags. This is the approach most HTML generation tools take: you simply define hierarchies of tags and are done with it. But let&rsquo;s imagine that I want to write a component of a page for displaying the navbar. I want this to be &ldquo;plug and play&rdquo;: I simply call the function at the right time, and the navbar is inserted at the correct point in the hierarchy.

This is where our superficial HTML generation breaks down. Our navbar likely consists of some CSS and JavaScript in addition to HTML. By the time we call the navbar function, we have already rendered the +&lt;head&gt;+ tag, so it is too late to add a new +&lt;style&gt;+ tag for our CSS declarations. Under normal strategies, we would need to break up our navbar function into three parts: HTML, CSS, and JavaScript, and make sure that we always call all three pieces.

Widgets take a different approach. Instead of viewing an HTML document as a monolithic tree of tags, widgets see a number of distinct components in the page. In particular:


* The title


* External stylesheets


* External JavaScript


* CSS declarations


* JavaScript code


* Arbitrary +&lt;head&gt;+ content


* Arbitrary +&lt;body&gt;+ content

Different components have different semantics. For example, there can only be one title, but there can be multiple external scripts and stylesheets. However, those external scripts and stylesheets should only be included once. Arbitrary head and body content, on the other hand, has no limitation (someone may want to have five lorem ipsum blocks after all).

The job of a widget is to hold onto these disparate components and apply proper logic for combining different widgets together. This consists of things like taking the first title set and ignoring others, filtering duplicates from the list of external scripts and stylesheets, and concatenating head and body content.

[[I_sect15_d1e2058]]

=== Constructing Widgets

In order to use widgets, you&rsquo;ll obviously need to be able to get your hands on them. The most common way will be via the +ToWidget+ typeclass, and its +toWidget+ method. This allows you to convert your Shakespearean templates directly to a +Widget+: Hamlet code will appear in the body, Julius scripts inside a +&lt;script&gt;+ tag in the head, and Cassius and Lucius in a +&lt;style&gt;+ tag.


[NOTE]
====
You can actually override the default behavior and have the script and style code appear in a separate file. The scaffolded site provides this for you automatically. Additionally, we&rsquo;ll see in the Yesod typeclass chapter how to turn on asynchronous script loading, which will place your script content at the end of the body.


====


But what if you want to add some +&lt;meta&gt;+ tags, which need to appear in the head? Or if you want some JavaScript to appear in the body instead of the head? For these purposes, Yesod provides two additional type classes: +ToWidgetHead+ and +ToWidgetBody+. These work exactly as they seem they should.

In addition, there are a number of other functions for creating specific kinds of Widgets:

setTitle:: Turns some HTML into the page title.

addCassiusMedia, addLuciusMedia:: Works the same as toWidget, but takes an additional parameter to indicate what kind of media this applies to. Useful for creating print stylesheets, for instance.

addStylesheet:: Adds a reference, via a +&lt;link&gt;+ tag, to an external stylesheet. Takes a type-safe URL.

addStylesheetRemote:: Same as +addStylesheet+, but takes a normal URL. Useful for referring to files hosted on a CDN, like Google&rsquo;s jQuery UI CSS files.

addScript:: Adds a reference, via a +&lt;script&gt;+ tag, to an external script. Takes a type-safe URL.

addScriptRemote:: Same as +addScript+, but takes a normal URL. Useful for referring to files hosted on a CDN, like Google&rsquo;s jQuery.

[[I_sect15_d1e2143]]

=== Combining Widgets

The whole idea of widgets is to increase composability. You can take these individual pieces of HTML, CSS, and JavaScript, combine them together into something more complicated, and then combine these larger entities into complete pages. This all works naturally through the +Monad+ instance of +Widget+, meaning you can use do-notation to compose pieces together.

[[combining-widgets-x2]]
.Combining Widgets

====
[source, haskell]
----
myWidget1 = do
    toWidget [hamlet|<h1>My Title|]
    toWidget [lucius|h1 { color: green } |]

myWidget2 = do
    setTitle "My Page Title"
    addScriptRemote "http://www.example.com/script.js"

myWidget = do
    myWidget1
    myWidget2

-- or, if you want
myWidget' = myWidget1 >> myWidget2
----

====

[NOTE]
====
If you&rsquo;re so inclined, there&rsquo;s also a +Monoid+ instance of +Widget+, meaning you can use +mconcat+ or a +Writer+ monad to build things up. In my experience, it&rsquo;s easiest and most natural to just use do-notation.


====


[[I_sect15_d1e2174]]

=== Generate IDs

If we&rsquo;re really going for true code reuse here, we&rsquo;re eventually going to run into name conflicts. Let&rsquo;s say that there are two helper libraries that both use the class name &ldquo;foo&rdquo; to affect styling. We want to avoid such a possibility. Therefore, we have the +newIdent+ function. This function automatically generates a word that is unique for this handler.

[[generate-ids-x2]]
.Using newIdent

====
[source, haskell]
----
getRootR = defaultLayout $ do
    headerClass <- lift newIdent
    toWidget [hamlet|<h1 .#{headerClass}>My Header|]
    toWidget [lucius| .#{headerClass} { color: green; } |]
----

====

[NOTE]
====
You might be wondering: what does lift mean? A +Widget+ is a monad transformer, sitting on top of a +Handler+. +newIdent+ is a function of a +Handler+, so we need to &ldquo;lift&rdquo; the function from the +Handler+ layer to the +Widget+ layer to use it. We can actually use this same approach to perform complex actions, like database queries, from within a widget. We&rsquo;ll cover that when we discuss Yesod&rsquo;s monads.


====


[[I_sect15_d1e2209]]

=== whamlet

Let&rsquo;s say you&rsquo;ve got a fairly standard Hamlet template that embeds another Hamlet template to represent the footer:


[source, haskell]
----
page = [hamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]

footer = [hamlet|
<footer>
    <p>That's all folks!
|]
----

That works fine if the footer is plain old HTML, but what if we want to add some style? Well, we can easily spice up the footer by turning it into a Widget:


[source, haskell]
----
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>That's all folks!
|]
----

But now we&rsquo;ve got a problem: a Hamlet template can only embed another Hamlet template; it knows nothing about a Widget. This is where +whamlet+ comes in. It takes exactly the same syntax as normal Hamlet, and variable (#{...}) and URL (@{...}) interpolation are unchanged. But embedding (^{...}) takes a +Widget+, and the final result is a +Widget+. To use it, we can just do:


[source, haskell]
----
page = [whamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]
----

There is also +whamletFile+, if you would prefer to keep your template in a separate file.


[NOTE]
====
The scaffolded site has an even more convenient function, +widgetFile+, which will also include your Lucius, Cassius, and Julius files automatically. We&rsquo;ll cover that in the scaffolding chapter.


====



==== Types

You may have noticed that I&rsquo;ve been avoiding type signatures so far. That&rsquo;s because there&rsquo;s a little bit of a complication involved here. At the most basic level, all you need to know is that there&rsquo;s a type synonym called +Widget+ which you will almost always use. The technical details follow, but don&rsquo;t worry if it&rsquo;s a little hazy.

There isn&rsquo;t actually a +Widget+ type defined in the Yesod libraries, since the exact meaning of it changes between sites. Instead, we have a more general type +GWidget sub master a+. The first two parameters give the sub and master foundation types, respectively. The final parameter is the contained value, just like any +Monad+ has.

So what&rsquo;s the deal with that sub/master stuff? Well, when you&rsquo;re writing some reusable code, such as a CRUD application, you can write it as a subsite that can be embedded within any other Yesod application. In such a case, we need to keep track of information for both the sub and master sites. The simplest example is for the type-safe URLs: Yesod needs to know how to take a route for your CRUD subsite and turn it into a route for the master site so that it can be properly rendered.

However, that sub/master distinction only ever matters when you&rsquo;re interacting with subsites. When you&rsquo;re writing your standard response code, you&rsquo;re dealing with just your application, and so the sub and master sites will be the same. Since this is the most common case, the scaffolded site declares a type synonym to help you out. Let&rsquo;s say your foundation type is MyCoolApp, it will define +type Widget = GWidget MyCoolApp
          MyCoolApp ()+. Therefore, we can get some very user-friendly type signatures on our widgets:


[source, haskell]
----
footer :: Widget
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>That's all folks!
|]

page :: Widget
page = [whamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]
----

If you&rsquo;ve been paying close attention, you might be confused. We used +lift+ on +Widget+ in the ID generation example above, but +GWidget+ isn&rsquo;t actually a monad transformer. What&rsquo;s going on here? Well, in older versions of Yesod, it _was_ a transformer around the +Handler+ type. Unfortunately, this led to difficult-to-parse error messages. As a result, +GWidget+ is now a +newtype+ wrapper that hides away its monad-transformer essence. But we still want to be able to +lift+ functions from the inner +Handler+ monad.

To solve this, Yesod provides an alternate, more general +lift+ function that works for both standard +MonadTrans+ instances, and special +newtype+ wrappers like +GWidget+. As a result, you can pretend like +GWidget+ is a standard transformer, while still getting to keep your nice error message.

One last point: just like we have the breakdown between +Widget+ and +GWidget+, we have a similar breakdown between +Handler+ and +GHandler+.

[[I_sect15_d1e2333]]

=== Using Widgets

It&rsquo;s all well and good that we have these beautiful Widget data types, but how exactly do we turn them into something the user can interact with? The most commonly used function is +defaultLayout+, which essentially has the type signature +Widget -&gt; Handler RepHtml+. (I say &ldquo;essentially&rdquo; because of the whole +GHandler+ issue.) +RepHtml+ is a data type containing some raw HTML output ready to be sent over the wire.

+defaultLayout+ is actually a typeclass method, which can be overridden for each application. This is how Yesod apps are themed. So we&rsquo;re still left with the question: when we&rsquo;re inside +defaultLayout+, how do we unwrap a +Widget+? The answer is +widgetToPageContent+. Let&rsquo;s look at some (simplified) types:


[source, haskell]
----
widgetToPageContent :: Widget -> Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }
----

This is getting closer to what we need. We now have direct access to the HTML making up the head and body, as well as the title. At this point, we can use Hamlet to combine them all together into a single document, along with our site layout, and we use +hamletToRepHtml+ to render that Hamlet result into actual HTML that&rsquo;s ready to be shown to the user. The next figure demonstrates this process.

[[using-widgets-x6]]
.Using widgetToPageContent

====
[source, haskell]
----
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent widget
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        <style>body { font-family: verdana }
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout
----

====

[NOTE]
====
You may have noticed that we used +GWidget+ and +GHandler+ instead of +Widget+ and +Handler+. That&rsquo;s because +defaultLayout+ is a method that can be called by subsites to ensure that they get the same styling as the master site. Therefore, we need to keep our types flexible here.


====


This is all well and good, but there&rsquo;s one thing that bothers me: that +style+ tag. There are a few problems with it:


* Unlike Lucius or Cassius, it doesn&rsquo;t get compile-time checked for correctness.


* Granted that the current example is very simple, but in something more complicated we could get into character escaping issues.


* We&rsquo;ll now have two style tags instead of one: the one produced by +myLayout+, and the one generated in the +pageHead+ based on the styles set in the widget.

We have one more trick in our bag to address this: we apply some last-minute adjustments to the widget itself before calling +widgetToPageContent+. It&rsquo;s actually very easy to do: we just use do-notation again, as in <<using-widgets-last-minute-widget-adjustment>>.

[[using-widgets-last-minute-widget-adjustment]]
.Last-Minute Widget Adjustment

====
[source, haskell]
----
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent $ do
        widget
        toWidget [lucius| body { font-family: verdana } |]
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]
----

====
[[I_sect15_d1e2436]]

=== Summary

The basic building block of each page is a widget. Individual snippets of HTML, CSS, and JavaScript can be turned into widgets via the polymorphic +toWidget+ function. Using do-notation, you can combine these individual widgets into larger widgets, eventually containing all the content of your page.

Unwrapping these widgets is usually performed within the +defaultLayout+ function, which can be used to apply a unified look-and-feel to all your pages.

