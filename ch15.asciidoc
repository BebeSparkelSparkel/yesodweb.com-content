[[I_chapter4_d1e7253]]

== Scaffolding and the Site Template

So you&rsquo;re tired of running small examples, and ready to write a real site? Then you&rsquo;re at the right chapter. Even with the entire Yesod library at your fingertips, there are still a lot of steps you need to go through to get a production-quality site setup:


* Config file parsing


* Signal handling (*nix)


* More efficient static file serving


* A good file layout

The scaffolded site is a combination of many Yesoders&rsquo; best practices +++<?oxy_comment_start author="ifebres" timestamp="20120405T161506-0400" comment="Changed from &quot;combined&quot; to avoid repetition."?>+++brought+++<?oxy_comment_end?>+++ together into a ready-to-use skeleton for your sites. It is highly recommended for all sites. This chapter will explain the overall structure of the scaffolding, how to use it, and some of its less-than-obvious features.

For the most part, this chapter will not contain code samples. It is recommended that you follow along with an actual scaffolded site.


[NOTE]
====
Due to the nature of the scaffolded site, it is the most fluid component of Yesod, and can change from version to version. It is possible that the information in this chapter is slightly outdated.


====


[[I_sect14_d1e7282]]

=== How to Scaffold



The yesod package installs both a library and an executable (conveniently named _yesod_ as well). This executable provides a few commands (run _yesod_ by itself to get a list). In order to generate a scaffolding, the command is _yesod init_. This will start a question-and-answer process where you get to provide basic details (your name, the project name, etc). After answering the questions, you will have a site template in a subfolder with the name of your project.

The most important of these questions is the database backend. You get four choices here: SQLite, PostgreSQL, MongoDB, and tiny. tiny is not a database backend; instead, it is specifying that you do not want to use any database. This option also turns off a few extra dependencies, giving you a leaner site overall. The remainder of this chapter will focus on the scaffoldings for one of the database backends. There will be minor differences for the tiny backend.

After creating your files, the scaffolder will print a message about getting started. It gives two sets of options for commands: one using _cabal_, and the other using _cabal-dev_. _cabal-dev_ is basically a wrapper around cabal that causes all dependencies to be built in a sandbox. Using it is a good way to ensure that installing other packages will not break your site setup. It is strongly recommended. If you don&rsquo;t have _cabal-dev_, you can install it by running _cabal install cabal-dev_.

Note that you really do need to use the _cabal install --only-dependencies_ (or _cabal-dev install --only-dependencies_) command. Most likely, you do not yet have all the dependencies your site needs in place. For example, neither the database backends nor the Javascript minifier (hjsmin) are +++<?oxy_comment_start author="ifebres" timestamp="20120406T101649-0400" comment="Replaced &quot;installed&quot; to avoid repetition."?>+++included+++<?oxy_comment_end?>+++ when installing the +yesod+ package.

Finally, to launch your development site, you would use _yesod devel_ (or _yesod --dev devel_). This site will automatically rebuild and reload whenever you change your code.

[[I_sect14_d1e7346]]

=== File Structure



The scaffolded site is built as a fully cabalized Haskell package. In addition to source files, config files, templates, and static files are produced as well.


==== Cabal File



Whether directly using _cabal_, or indirectly using _yesod devel_, building your code will always go through the cabal file. If you open the file, you&rsquo;ll see there are both library and executable blocks. Only one of these is built at a time, depending on the value of the +library-only+ flag. If +library-only+ is turned on, then the library is built, which is how _yesod devel_ calls your app. Otherwise, the executable is built.

The +library-only+ flag should only be used by _yesod devel_; you should never be explicitly passing it into _cabal_. There is an additional flag, +dev+, that allows cabal to build an executable, but turns on some of the same features as the library-only flag, i.e., no optimizations and reload versions of the Shakespearean template functions.

In general, you will build as follows:


* When developing, use _yesod devel_ exclusively.


* When building a production build, perform _cabal clean &amp;&amp; cabal configure &amp;&amp; cabal build_. This will produce an optimized executable in your _dist_ folder.
[NOTE]
====
In the past we had a +-fproduction+ flag. If you produced a scaffolded site in the past, you may have to use this flag to get a production build.


====




You&rsquo;ll also notice that we specify all language extensions in the cabal file. The extensions are specified _twice_: once for the executable, and once for the library. If you add any extensions to the list, add it to both places.

You might be surprised to see the +NoImplicitPrelude+ extension. We turn this on since the site includes its own module, +Import+, with a few changes to the Prelude that make working with Yesod a little more convenient.

The last thing to note is the exported-modules list. If you add any modules to your application, you *must* update this list to get yesod devel to work correctly. Unfortunately, neither Cabal nor GHC will give you a warning if you forgot to make this update, and instead you&rsquo;ll get a very scary-looking error message from yesod devel.
[NOTE]
====
One of our planned improvements to _yesod devel_ is to check if there are any missing modules.


====





==== Routes and Entities



Multiple times in this book, you&rsquo;ve seen a comment like &ldquo;We&rsquo;re declaring our routes/entities with quasiquotes for convenience. In a production site, you should use an external file.&rdquo; The scaffolding uses such an external file.

Routes are defined in _config/routes_, and entities in _config/models_. They have the exact same syntax as the quasiquoting you&rsquo;ve seen throughout the book, and _yesod devel_ knows to automatically recompile the appropriate modules when these files change.

The _models_ files is referenced by +Model.hs+. You are free to declare whatever you like in this file, but here are some guidelines:


* Any data types used in _entities_ *must* be imported/declared in _Model.hs_, above the +persistFile+ call.


* Helper utilities should either be declared in +Import.hs+ or, if very model-centric, in a file within the +Model+ folder and imported into _Import.hs_.


==== Foundation and Application Modules



The +mkYesod+ function, which we have used throughout the book, declares a few things:


* Route type


* Route render function


* Dispatch function

The dispatch function refers to all of the handler functions. Therefore, all of those must either be defined in the same file as the dispatch function, or be imported by the dispatch function.

Meanwhile, the handler functions will almost certainly refer to the route type. Therefore, _they_ must be either in the same file where the route type is defined, or must import that file. If you follow the logic here, your entire application must essentially live in a single file!

Clearly, this isn&rsquo;t what we want. So instead of using +mkYesod+, the scaffolding site uses a decomposed version of the function. +Foundation+ calls +mkYesodData+, which declares the route type and render function. Since it does not declare the dispatch function, the handler functions need not be in scope. +Import.hs+ imports +Foundation.hs+, and all the handler modules import +Import.hs+.

In +Application.hs+, we call +mkYesodDispatch+, which creates our dispatch function. For this to work, all handler functions must be in scope, so be sure to add an import statement for any new handler modules you create.

Other than that, _Application.hs_ is pretty simple. It provides two functions: +withDevelAppPort+ is used by _yesod devel_ to launch your app, and +getApplication+ is used by the executable to launch.

_Foundation.hs_ is much more exciting. It:


* Declares your foundation data type


* Declares a number of instances, such as +Yesod+, +YesodAuth+, and +YesodPersist+


* Imports the messages files. If you look for the line starting with +mkMessage+, you will see that it specifies the folder containing the messages (_messages_) and the default language (en, for English)

This is the right file for adding extra instances for your foundation, such as +YesodAuthEmail+ or +YesodBreadcrumbs+.

We&rsquo;ll be referring back to this file later, as we discussed some of the special implementations of +Yesod+ typeclass methods.


==== Import



The +Import+ module was born out of a few commonly recurring patterns.


* I want to define some helper functions (maybe the +&lt;&gt; = mappend+ operator) to be used by all handlers.


* I&rsquo;m always adding the same five import statements (+Data.Text+, +Control.Applicative+, etc) to every handler module.


* I want to make sure I never use some evil function (+head+, +readFile+, ...) from +Prelude+.
[NOTE]
====
Yes, evil is hyperbole. If you&rsquo;re wondering why I listed those functions as bad: +head+ is partial, and throws exceptions on an empty list, and +readFile+ uses lazy I/O, which doesn&rsquo;t close file handles quickly enough. Also, +readFile+ uses +String+ instead of +Text+.


====




The solution is to turn on the +NoImplicitPrelude+ language extension, re-export the parts of +Prelude+ we want, add in all the other stuff we want, define our own functions as well, and then import this file in all handlers.


==== Handler Modules



Handler modules should go inside the _Handler_ folder. The site template includes one module: _Handler/Root.hs_. How you split up your handler functions into individual modules is your decision, but a good rule of thumb is:


* Different methods for the same route should go in the same file, e.g., +getBlogR+ and +postBlogR+.


* Related routes can also usually go in the same file, e.g., +getPeopleR+ and +getPersonR+.

Of course, it&rsquo;s entirely up to you. When you add a new handler file, make sure you do the following:


* Add it to version control (you _are_ using version control, right?).


* Add it to the cabal file.


* Add it to the _Application.hs_ file.


* Put a module statement at the top, and an +import Import+ line below it.


[NOTE]
====
One of the planned improvements to the _yesod_ executable is to automate these four steps.


====


[[I_sect14_d1e7726]]

=== widgetFile



It&rsquo;s very common to want to include CSS and JavaScript specific to a page. You don&rsquo;t want to have to remember to include those Lucius and Julius files manually every time you refer to a Hamlet file. For this, the site template provides the +widgetFile+ function.

If you have a handler function:


[source, haskell]
----
getRootR = defaultLayout $(widgetFile "homepage")
----

, Yesod will look for the following files:


*  _templates/homepage.hamlet_ 


*  _templates/homepage.lucius_ 


*  _templates/homepage.cassius_ 


*  _templates/homepage.julius_ 

If any of those files are present, they will be automatically included in the output.


[NOTE]
====
Due to the nature of how this works, if you launch your app with _yesod devel_, and then create a new file (e.g., _templates/homepage.julius_), the contents will _not_ be included until the file calling +widgetFile+ is recompiled. In such a case, you may need to force a save of that file to get _yesod devel_ to recompile.


====


[[I_sect14_d1e7786]]

=== defaultLayout



One of the first things you&rsquo;re going to want to customize is the look of your site. The layout is actually broken up into two files:


* _templates/default-layout-wrapper.hamlet_ contains just the basic shell of a page. This file is interpreted as plain Hamlet, not as a +++<?oxy_comment_start author="ifebres" timestamp="20120406T104153-0400" comment="Should this be capitalized?"?>+++Widget+++<?oxy_comment_end?>+++, and therefore cannot refer to other widgets, embed i18n strings, or add extra CSS/JS.


* _templates/default-layout.hamlet_ is where you would put the bulk of your page. You *must* remember to include the +widget+ value in the page, as that contains the per-page contents. This file is interpreted as a Widget.

Also, since default-layout is included via the +widgetFile+ function, any Lucius, Cassius, or Julius files named _default-layout.*_ will automatically be included as well.

[[I_sect14_d1e7821]]

=== Static Files



The scaffolded site automatically includes the static file subsite, optimized for serving files that will not change over the lifetime of the current build. What this means is that:


* When your static file identifiers are generated (e.g., _static/mylogo.png_ becomes +mylogo_png+), a query-string parameter is added to it with a hash of the contents of the file. All of this happens at compile time.


* When +yesod-static+ serves your static files, it sets expiration headers far in the future, and includes an etag based on a hash of your content.


* Whenever you embed a link to +mylogo_png+, the rendering includes the query-string parameter. If you change the logo, recompile, and launch your new app, the query string will have changed, causing users to ignore the cached copy and download a new version.

Additionally, you can set a specific static root in your _Settings.hs_ file to serve from a different domain name. This has the advantage of not requiring transmission of cookies for static file requests, and also lets you offload static file hosting to a CDN or a service like Amazon S3. See the comments in the file for more details.

Another optimization is that CSS and JavaScript included in your widgets will not be included inside your HTML. Instead, their contents will be written to an external file, and a link given. This file will be named based on a hash of the contents as well, meaning:


. Caching works properly.


. Yesod can avoid an expensive disk write of the CSS/JavaScript file contents if a file with the same hash already exists.

Finally, all of your JavaScript is automatically minified via hjsmin.

[[I_sect14_d1e7869]]

=== Conclusion



The purpose of this chapter was not to explain every line that exists in the scaffolded site, but instead to give a general overview of how it works. The best way to become more familiar with it is to jump right in and start writing a Yesod site with +++<?oxy_comment_start author="ifebres" timestamp="20120406T104601-0400" comment="It = scaffolded site? Unsure of the pronoun&apos;s antecdent."?>+++it+++<?oxy_comment_end?>+++.

